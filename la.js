const axios = require('axios');
const config = require('./config.json');
const crypto = require('crypto');
const tags = require('common-tags');
const _ = require('underscore');
const xml2js = require('xml2js');
const parser = new xml2js.Parser({explicitArray: false});

module.exports = {
  callAuthentication: function (key, method) {
    //returns sig and epoch generated by epoch + method + key
    const epoch = (new Date).getTime();
    const salt = key.akid + method + epoch;
    const hash = crypto.createHmac('sha1', key.password);
    hash.update(salt);
    return {sig: encodeURIComponent(hash.digest('base64')), expires: epoch};
  },
  institutionalLoginUrls: function(key, username, password) {
    const base = {
      baseURL: config.baseurl,
      timeout: 10000
    };
    const method = 'institutional_login_urls';
    const callAuth = this.callAuthentication(key, method);
    return axios
      .get(
        tags.oneLineTrim`
        ${config.baseurl}${config.api}/utilities/${method}
        ?login_or_email=${encodeURIComponent(username)}&password=${encodeURIComponent(password)}
        &akid=${key.akid}&expires=${callAuth.expires}&sig=${callAuth.sig}
        `
        , base
      )
      .then((response) => {
        return new Promise(function (resolve, reject) {
          parser.parseString(response.data, function (err, result) {
            if (err) {
              reject(err);
            }
            else {
              resolve(result);
            }
          });
        });
      })
      .catch((error) => {
        return Promise.reject(error.message)
      })
  },
  accessInfo: function (key, username, password) {
    const base = {
      baseURL: config.baseurl,
      timeout: 10000
    };
    const method = 'user_access_info';
    const callAuth = this.callAuthentication(key, method);
    return axios
      .get(
        tags.oneLineTrim`
        ${config.baseurl}${config.api}/users/${method}
        ?login_or_email=${encodeURIComponent(username)}&password=${encodeURIComponent(password)}
        &akid=${key.akid}&expires=${callAuth.expires}&sig=${callAuth.sig}
        `
        , base
      )
      .then((response) => {
        return new Promise(function (resolve, reject) {
          parser.parseString(response.data, function (err, result) {
            if (err) {
              reject(err);
            }
            else {
              resolve(result);
            }
          });
        });
      })
      .catch((error) => {
        return Promise.reject(error.message)
      })
  },
  getDefaultNoteBook: function (userNBs) {
    return _.find(userNBs.notebook, (item) => {
      return item['is-default']._ === 'true';
    });
  },
  getNotebookInfo: function (key, uid, nbid) {
    const base = {
      baseURL: config.baseurl,
      timeout: 10000
    };
    const method = 'notebook_info';
    const callAuth = this.callAuthentication(key, method);
    return axios
      .get(
        tags.oneLineTrim`
        ${config.baseurl}${config.api}/notebooks/${method}
        ?uid=${uid}&nbid=${nbid}
        &akid=${key.akid}&expires=${callAuth.expires}&sig=${callAuth.sig}
        `
        , base
      )
      .then((response) => {
        return new Promise(function (resolve, reject) {
          parser.parseString(response.data, function (err, result) {
            if (err) {
              reject(err);
            }
            else {
              resolve(result);
            }
          });
        });
      })
      .catch((error) => {
        return Promise.reject(error.message)
      })
  },
  getTree: function (key, uid, nbid, parentTreeId) {
    const base = {
      baseURL: config.baseurl,
      timeout: 10000
    };
    const method = 'get_tree_level';
    const callAuth = this.callAuthentication(key, method);
    let req = `${config.baseurl}${config.api}/tree_tools/${method}`;
    req += `?uid=${uid}&nbid=${nbid}&parent_tree_id=${parentTreeId}`;
    req += `&akid=${key.akid}&expires=${callAuth.expires}&sig=${callAuth.sig}`;
    return axios
      .get(req, base)
      .then((response) => {
        return new Promise(function (resolve, reject) {
          parser.parseString(response.data, function (err, result) {
            if (err) {
              reject(err);
            }
            else {
              resolve(result);
            }
          });
        });
      })
      .catch((error) => {
        return Promise.reject(error.message)
      })
  },
  insertNode: function (key, uid, nbid, parentTreeId, displayText, isFolder) {
    const base = {
      baseURL: config.baseurl,
      timeout: 10000
    };
    const method = 'insert_node';
    const callAuth = this.callAuthentication(key, method);
    let req = `${config.baseurl}${config.api}/tree_tools/${method}`;
    req += `?uid=${uid}&nbid=${nbid}&parent_tree_id=${parentTreeId}&display_text=${displayText}&is_folder=${isFolder}`;
    req += `&akid=${key.akid}&expires=${callAuth.expires}&sig=${callAuth.sig}`;
    return axios
      .get(req, base)
      .then((response) => {
        return new Promise(function (resolve, reject) {
          parser.parseString(response.data, function (err, result) {
            if (err) {
              reject(err);
            }
            else {
              resolve(result);
            }
          });
        });
      })
      .catch((error) => {
        return Promise.reject(error.message)
      });
  },
  addEntry: function (key, uid, nbid, pid, partType, entryData) {
    const base = {
      baseURL: config.baseurl,
      timeout: 10000
    };
    const method = 'add_entry';
    const callAuth = this.callAuthentication(key, method);
    let req = `${config.baseurl}${config.api}/entries/${method}`;
    req += `?uid=${uid}&nbid=${nbid}&pid=${pid}&part_type=${partType}&entry_data=${entryData}`;
    req += `&akid=${key.akid}&expires=${callAuth.expires}&sig=${callAuth.sig}`;
    return axios
      .get(req, base)
      .then((response) => {
        return new Promise(function (resolve, reject) {
          parser.parseString(response.data, function (err, result) {
            if (err) {
              reject(err);
            }
            else {
              resolve(result);
            }
          });
        });
      })
      .catch((error) => {
        return Promise.reject(error.message)
      });
  }

};
